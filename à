\documentclass[a4paper, 12pt]{report}

\usepackage[dvipsnames]{xcolor}

%%%%%%%%%%%%%%%%
% Set Variables %
%%%%%%%%%%%%%%%%

\def\useItalian{0}  % 1 = Italian, 0 = English

\def\courseName{Quantum Computing}

\def\coursePrerequisites{TODO}

% \def\book{"My book",\\Author 1, ...}

% \def\authorName{Simone Bianco}
% \def\email{bianco.simone@outlook.it}
% \def\github{https://github.com/Exyss/university-notes}
% \def\linkedin{https://www.linkedin.com/in/simone-bianco}

\def\authorName{Alessio Bandiera}
\def\email{alessio.bandiera02@gmail.com}
\def\github{https://github.com/aflaag-notes}
\def\linkedin{https://www.linkedin.com/in/alessio-bandiera-a53767223}

% Do not change

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../../packages/Nyx/nyx-packages}
\usepackage{../../packages/Nyx/nyx-styles}
\usepackage{../../packages/Nyx/nyx-frames}
\usepackage{../../packages/Nyx/nyx-macros}
\usepackage{../../packages/Nyx/nyx-title}
\usepackage{../../packages/Nyx/nyx-intro}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../../packages/Nyx/logo.png}

\if\useItalian1
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} Universit√† di Roma}
    \faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
    \department{Dipartimento di Informatica}
    \ifdefined\book
        \subtitle{Appunti integrati con il libro \book}
    \fi
    \author{\textit{Autore}\\\authorName}
\else
    \institute{\curlyquotes{\hspace{0.25mm}Sapienza} University of Rome}
    \faculty{Faculty of Information Engineering,\\Informatics and Statistics}
    \department{Department of Computer Science}
    \ifdefined\book
        \subtitle{Lecture notes integrated with the book \book}
    \fi
    \author{\textit{Author}\\\authorName}
\fi

\title{\courseName}
\date{\today}

% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

\addbibresource{./references.bib}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
\maketitle

% The following style changes are valid only inside this scope 
{
	\hypersetup{allcolors=black}
	\fancypagestyle{plain}{%
		\fancyhead{}        % clear all header fields
		\fancyfoot{}        % clear all header fields
		\fancyfoot[C]{\thepage}
		\renewcommand{\headrulewidth}{0pt}
		\renewcommand{\footrulewidth}{0pt}}

	\romantableofcontents
}

\introduction

%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction on Quantum Computation}

\section{The Qubit}

\href{https://en.wikipedia.org/wiki/Quantum_computing}{Quantum computing} is a rapidly developing discipline that explores how the laws of quantum mechanics can be used to \tit{process information}. While classical computation is based on \tit{bits} that take values of either 0 or 1, quantum computation relies on quantum bits, or \tbf{qubits}. A qubit can exist in a \curlyquotes{superposition} of classical states, allowing it to encode richer information than a single bit. Furthermore, qubits can exhibit particular properties that enable forms of information processing with no classical counterpart. Such properties provide the foundation for algorithms that promise to solve certain problems more efficiently than their classical analogues.

The design of quantum algorithms requires a different perspective from that of classical computation. In classical computer science, the majority of widely studied algorithms are \tit{deterministic}, meaning that for a given input they will always produce the \tit{same output}. Some algorithms are \tit{randomized}, making use of probability to achieve efficiency or simplicity, yet even in those cases the computation itself is ultimately classical in nature. In fact, to achieve such \tit{randomness} classical algorithms employ \tbf{pseudo-random number generation}, which must ultimately produce \underline{finite} sequences.

Quantum computation, by contrast, \tit{incorporates probability} at its core. The act of measuring a quantum system does not reveal a single, predetermined result, but rather yields one outcome from a distribution of possible outcomes, with probabilities governed by the system's quantum state. This fundamental probabilistic characteristic distinguishes quantum algorithms from their classical counterparts.

In fact, in the context of quantum computing we are often interested in \tbf{probabilistic algorithms}: for such algorithms, a given input $i$ can lead to a finite set of possible outputs $o_1, \ldots, o_N$, each occurring with an associated probability $p_1, \ldots, p_N$ --- where $\sum_{i = 1}^n{p_i} = 1$.

As previously mentioned, the quantum equivalent of the classical bits are the \tbf{qubit}, but define the qubits we first need to define some preliminary concepts. The following vectors are called \tbf{basis states} $$\ket{0} := \rmat{1 \\ 0} \quad \quad \ket 1 := \rmat{0 \\ 1}$$ and they represent the classical bits 0 and 1 respectively --- the notation above is called \curlyquotes{braket} notation and it will be explored in greater detail in later sections.

So what is a qubit? A qubit is the basic unit of information in quantum computing, which represents a \tbf{superposition} of states simultaneously --- note that we will refer to qubits and their states interchangeably, since the only thing that we care about a qubit is its own state

In practice, the state of a qubit is a vector $$\ket \psi = \alpha \ket 0 + \beta \ket 1 = \alpha \rmat{1 \\ 0 } + \beta \rmat{0 \\ 1} = \rmat{\alpha \\ \beta}$$ where $\alpha, \beta \in \C$ such that $\abs \alpha ^2 + \abs \beta ^2 = 1$ are called \tbf{probability amplitudes}. But why are we talking about probabilities in the first place? The \curlyquotes{true} state of a qubit \tbf{cannot be observed}, and we say that the qubit is in a \tit{superpotion} of $\ket 0$ and $\ket 1$ in the sense that $\alpha$ and $\beta$ describe the probabilities of getting either states once the qubit is measured. This is because to know the value of a qubit we have to \tit{measure it}, and the measurement operation itself will make the qubit \tit{collapse} into either $\ket 0$ or $\ket 1$ with probabilities $\abs \alpha ^2$ and $\abs \beta ^2$ respectively, i.e. $$\Pr[\mbox{measured qubit is $\ket 0$}] = \abs \alpha ^2 \quad \quad \Pr[\mbox{measured qubit is $\ket 1$}] = \abs \beta ^2$$ To use a more compact notation, we will denote this property as follows: $$\alpha \ket 0 + \beta \ket 1 \soe{ll}{\ket 0 & @ \  \abs{\alpha}^2 \\ \ket 1 & @ \ \abs{\beta}^2}$$ where the $@$ notation (read as \curlyquotes{at}) denotes the probabilty of the corresponding outcome. Note that if we measure a collapsed qubit we will keep observing the same state indefinitely.

In reality, to be precise qubits actually collapse into any multiple $z \ket 0$ or $z\ket 1$, where $z \in \C$ is a complex number such that $\abs z = 1$, but this is not relevant from a physical point of view. In fact, for any $\theta$ physicists treat $\ket \psi = \ket 0$ and $\ket {\psi'} = e^{i \theta} \ket 0 $ as the \tit{same physical state}, because probabilities depend on squared magnitudes and thus $$\abs{e^{i \theta} \alpha}^2 = \abs \alpha^2$$ (and the same applies for $\beta$ too) even though $\ket \psi$ and $\ket {\psi'}$ are different vectors mathematically.

\section{Qubit operations}

What can we do with qubits other then \tit{measure them}? The operations that can be applied on qubits are restricted to \tbf{unitary transformations}.

\begin{frameddefn}{Unitary transformation}
	A transformation $U$ is said to be \tbf{unitary} if it preserves the norm of its input vector, i.e. $$\forall v \quad \norm{Uv} = \norm v$$
\end{frameddefn}

For instance, the identity matrix $I$ is an example of trivial unitary transformation, but also the NOT matrix, which is the following $$\mbox{NOT} := \rmat{0 & 1 \\ 1 & 0}$$ which has the effect of \tit{swapping} the input basis state $$\mbox{NOT} \ket 0 = \ket 1 \quad \quad \mbox{NOT} \ket 1 = \ket 0$$ This matrix behaves as the classical NOT gate with the usual bits in classical computing, in fact will refer to \tit{transformations} and \tit{gates} interchangeably.

More in general, the NOT operation belongs to a family of operation represented by the so called \tbf{Pauli matrices}.

\begin{frameddefn}{Pauli matrices}
	The \tbf{Pauli matrices} are the following four $2 \times 2$ matrices: $$I := \rmat{1 & 0 \\ 0 & 1} \quad \sigma_x := \rmat{0 & 1 \\ 1 & 0} \quad \sigma_y := \rmat{0 & -i \\ i & 0} \quad \sigma_z := \rmat{1 & 0 \\ 0 & -1}$$
\end{frameddefn}

In particular, we observe that the second matrix $\sigma_x$ is exactly the matrix of the NOT operator. We will see the Z and Y operators --- representing the other two matrices, respectively --- as well in later sections.

Another very important transformation is represented by the \tbf{Hadamard gate}, which is the following matrix $$H := \dfrac{1}{\sqrt 2}\rmat{1 & 1 \\ 1 & -1}$$ This matrix has the effect of \curlyquotes{mapping} classical states into superpositions: $$H \ket 0 = \dfrac{1}{\sqrt 2}\rmat{1 & 1 \\ 1 & -1} \rmat{1 \\ 0} = \dfrac{1}{\sqrt 2} \rmat{1 \\ 0} = \dfrac{1}{\sqrt 2} (\ket 0 + \ket 1) \soe{ll}{\ket 0 & @ \  \frac{1}{2} \\ \ket 1 & @ \  \frac{1}{2}}$$ For instance, in this example given $\ket 0$ which represents the classical bit 0, we get a qubit as output of the linear transformation. In general, the operation performed by the Hadamard gate can be represented as follows: $$\forall a \in \{0, 1\} \quad \dfrac{1}{\sqrt 2} \rbk{\ket 0 + (-1)^a \ket 1}$$

As a side note, as we mentioned at the beginning of the chapter quantum mechanics has randomness intrinsically, and since the operation $H \ket 0$ returns a qubit that has 50\% of probability of being either $\ket 0$ or $\ket 1$ once measured, this operation provides a \underline{true} random number generator. \todo{side note on Hadamard gate really implemented?}

TODO \todo{bloch sphere too bored to do it}

\subsection{The tensor product}

So far we have dealt with only one qubit at a time, but what if we have two qubits? First, let's look at the classical counterpart. If we take two bits $a, b \in \{0, 1\}$, we can represent 4 possible binary numbers, namely 00, 01, 10 and 11, which we can algebraically obtain by computing the usual cartesian product $$\{0, 1\}^2 = \{0, 1\} \times \{0, 1\} = \{(0, 0), (0, 1), (1, 0), (1, 1)\}$$ Note that in the cartesian products it holds that:

\begin{itemize}
	\item the length of the tuples of the product is linear w.r.t. the number of factors of the cartesian products --- in this case, 2
	\item each element of a tuple is \tit{independent} from the other elements of the tuple
\end{itemize}

How can we evaluate all the possible states that two qubits can represent, instead? To answer this question, we need to introduce a new operator, which is called \tbf{tensor product}. Given two vectors $\rmat{a \\ b}$ and $\rmat{c \\ d}$, their tensor product is defined as follows $$\rmat{a \\ b} \otimes \rmat{c \\ d} := \rmat{ac \\ ad \\ bc \\ bd}$$ Hence, consider two qubits $$\ket \psi = \alpha_0 \ket 0 + \alpha_1 \ket 1 = \rmat{\alpha_0 \\ \alpha_1} \quad \quad \ket \phi = \beta \ket 0 + \beta_1 \ket 1 = \rmat{\beta_0 \\ \beta_1}$$ To obtain all the possible states of $\ket \psi$ and $\ket \phi$ we just have to compute the tensor product between them, which is
\begin{equation*}
	\begin{split}
		\ket \psi \otimes \ket \phi & = \rmat{\alpha_0           \\ \alpha_1} \otimes \rmat{\beta_0 \\ \beta_1} \\
		                            & = \alpha_0 \beta_0 \rmat{1 \\ 0 \\ 0 \\ 0 } + \alpha_0 \beta_1 \rmat{0 \\ 1 \\ 0 \\ 0} + \alpha_1 \beta_0 \rmat{0 \\ 0 \\ 1 \\ 0} + \alpha_1 \beta_1 \rmat{0 \\ 0 \\ 0 \\ 1}
	\end{split}
\end{equation*}
At the beginning of the chapter we defined $\ket 0$ and $\ket 1$ to be $\rmat{0 \\ 1}$ and $\rmat{1 \\ 0}$ without providing an explaination; now that we are dealing with more than 2 dimensions we can show why such names are used. In fact, we will use the following naming convention $$\ket{00} := \rmat{1 \\ 0 \\ 0 \\ 0 } \quad \ket {01} := \rmat{0 \\ 1 \\ 0 \\ 0} \quad \ket{10} := \rmat{0 \\ 0 \\ 1 \\ 0} \quad \ket{11} := \rmat{0 \\ 0 \\ 0 \\ 1}$$ and in general it holds that $$\ket{\mbox{bin}(i)} = e_i$$ where $\mbox{bin}(i)$ represents for the binary representation of $i$, and $e_i$ is the $i$-th vector of the canonical basis. This implies that we can rewrite the previous tensor product as follows: $$\ket \psi \otimes \ket \phi = \alpha_0 \beta_0 \ket{00} + \alpha_0 \beta_1 \ket{01} + \alpha_1 \beta_0 \ket{10} + \alpha_1 \beta_1 \ket {11} = \sum_{i, j \in \{0, 1\}}{\alpha_i \beta_j \ket{ij}}$$ As a final note, it can be easily proven that $$\forall i, j \in \{0, 1\} \quad \ket i \otimes \ket j = \ket{ij}$$

For example, given two qubits $$\ket \phi = \dfrac{1}{\sqrt 2} (\ket 0 + \ket 1) \quad \ket \psi = \dfrac{1}{\sqrt 2} (\ket 0 + \ket 1)$$ we get that
\begin{equation*}
	\begin{split}
		\ket \psi \otimes \ket \phi & = \rmat{\tfrac{1}{\sqrt 2}                                                   \\ \tfrac{1}{\sqrt 2}} \otimes \rmat{\tfrac{1}{\sqrt 2} \\ \tfrac{1}{\sqrt 2}} \\
		                            & = \rmat{\tfrac{1}{2}                                                         \\ \tfrac{1}{2} \\ \tfrac{1}{2} \\ \tfrac{1}{2}} \\
		                            & = \dfrac{1}{2}(\ket{00} + \ket{01} + \ket{10} + \ket{11})                    \\
		                            & \soe{ll}{\ket 0 \mbox{and} \ket 0                         & @ \ \tfrac{1}{4} \\ \ket 0 \mbox{and} \ket 1 & @ \ \tfrac{1}{4} \\ \ket 1 \mbox{and} \ket 0 & @ \ \tfrac{1}{4} \\ \ket 1 \mbox{and} \ket 1 & @ \ \tfrac{1}{4}}
	\end{split}
\end{equation*}
where the probabilities at the end refer to the two individual qubits. To recap, in general the tensor product $\ket \psi \otimes \ket \phi$ of two qubits encodes the superposition of 4 basis states, namely $\ket {00}$, $\ket{01}$, $\ket{10}$ and $\ket {11}$.

Moreover, the following property can be proved easily.

\begin{framedprop}{Distributive property of $\otimes$}
	Given three qubits $\ket \psi, \ket \phi$ and $\ket \chi$, it holds that $$(\ket \psi + \ket \phi) \otimes \ket \chi = \ket \psi \otimes + \ket \phi \otimes \ket \chi$$
\end{framedprop}

TODO \todo{tensor product tra matrici? me va?}

\subsection{Controlled operations}

Another familyh of very important gates in quantum computing is the \tit{controlled operations}. The first controlled operation that we are going to discuss is the so called \tbf{Controlled NOT (CNOT)} gate, which is defined as follows:

\begin{center}
	\begin{tabular}{cc|c}
		\hline
		$a$ & $b$ & $\mbox{CNOT}(a, b)$ \\
		\hline\hline
		0   & 0   & 0                   \\
		\hline
		0   & 1   & 1                   \\
		\hline
		1   & 0   & 1                   \\
		\hline
		1   & 1   & 0                   \\
		\hline
	\end{tabular}
\end{center}

In fact, the names comes from the fact that the first input $a$ is called \tit{control bit}, which if set to 1 will flip the \tit{target bit} $b$ --- in fact, in its implementation what actually happens is that $b$'s wire itself is flipped. Therefore, in general we will write that $$\mbox{CNOT}(a, b) = (a, a \oplus b)$$

First, we observe that this function is clearly not invertible, since for instance if we know that the output is 0 we still need the input $a$ to evaluate if $b$ was 0 or 1. Hence, to solve this issue we usually pair the output of CNOT with $a$ itself, so that we can actually invert the computation.

Moreover, so far we only dealt with transformation that only expected one qubit argument as input, but the CNOT gate would certainly need 2 inputs to perform any computation, so how do we provide two inputs to it? As we showed before, we konw that $$\forall i, j \in \{0, 1\} \quad \ket i \otimes \ket j = \ket{i j}$$ which directly implies that the vector $\ket{ij}$ encapsulated two qubits at once without ambiguity. Hence, we can actually leverage the tensor product to provide the input to the CNOT matrix, such that the quantum CNOT will behave as follows $$\mbox{CNOT}(\ket a \otimes \ket b) = \ket a \otimes \ket{a \oplus b}$$ Hence, the matrix that behaves as such is the following $$\mbox{CNOT} := \rmat{1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0}$$ which expects a $4 \times 1$ input vector, and outputs a $4 \times 1$ output vector as well.

Laslty, as for the CNOT operator, we can actually define controlled operators for both Y and Z, which are respectively called CY and CZ operators.

\subsection{Quantum circuits}

Now that we introduced a couple of quantum gates, we can show how computation is actually represented in quantum computing. For instance, consider the following picture:

\centeredimage[The NOT gate.]{0.8}{../assets/not.png}

In this example, we have 1 single input qubit, namely $q$, and the box labeled with an $X$ represents the NOT gate. We observe that, by convetion, all qubits in quantum circuits are assumed to be set to $\ket 0$.

In the following example, instead, it is represented how the Hadamard gate looks like in quantum circuits.

\centeredimage[The Hadamard gate.]{0.8}{../assets/h.png}

Moreover, if we consider two qubits as inputs $q_0$ and $q_1$, we can represent the CNOT operator as follows:

\centeredimage[The CNOT gate.]{0.8}{../assets/cnot.png}

We observe that $q_1$ then becomes the output of the CNOT operation, and $q_0$ remains unchanged. Lastly, the measurement operation is represented with the following picure:

\centeredimage[The measure operation.]{0.8}{../assets/meas.png}

In particular, in this cirtuit we see that:

\begin{itemize}
	\item the vertical \curlyquotes{double lines} reprents \tit{classical bits}
	\item the number 1 next to the label \curlyquotes{meas} indicates the number of qubits that have been measured
	\item the number 0 is the index of the measured qubit
\end{itemize}

\centeredimage[An exmaple of measurement of 2 qubits]{0.8}{../assets/meas2.png}

\section{Peculiarities of quantum mechanics}

\subsection{Quantum entanglment}

Consider the following quantum state $$\ket \psi = \dfrac{1}{\sqrt 2}\rbk{\ket {01} + \ket {10}}$$ Can this state be rewritten as the tensor product of two distinct quantum states? We observe that for this to be possible we would require some complex values $\alpha_0, \alpha_1, \beta_0, \beta_1$ such that $$\soe{l}{\alpha_0 \beta_0 = \alpha_1 \beta_1 = 0 \\ \alpha_0 \beta_1 = \alpha_1 \beta_0 = \tfrac{1}{\sqrt 2}}$$ but $\alpha_0 \beta_0 = 0$ implies that at least one between $\alpha_0$ and $\beta_0$ has to be 0, meaning that at least one between $\alpha_0\beta_1$ and $\alpha_1\beta_0$ has to be 0 as well. This proves that there is no such pair of quantum states which can describe $\ket \psi$ through the tensor product operation. In fact, we see that $$\ket \psi = \dfrac{1}{\sqrt 2}\rbk{\ket{01} + \ket{10}}  \soe{ll}{\ket{01} & @ \ \tfrac{1}{2} \\ \ket{10} & @ \ \tfrac{1}{2}}$$ Indeed, this particular state we chose is one of the so called \tbf{Bell states}.

\begin{frameddefn}{Bell states}
	The following are the four \tbf{Bell states}: $$\ket{\Phi^+} := \dfrac{1}{\sqrt 2}\rbk{\ket{00} + \ket{11}}$$ $$\ket{\Phi^-} := \dfrac{1}{\sqrt 2}\rbk{\ket{00} - \ket{11}}$$ $$\ket{\Psi^+} := \dfrac{1}{\sqrt 2}\rbk{\ket{01} + \ket{10}}$$ $$\ket{\Psi^-} := \dfrac{1}{\sqrt 2}\rbk{\ket{01} - \ket{10}}$$
\end{frameddefn}

Whenever we have a state $\ket \psi$ that cannot be represented as the tensor product of two simpler quantum states, we say that the state is \tbf{entangled} --- or that its possible outcomes are entangled. In particular, entangled states describe a very weird phenomenon first proposed as a thought experiment in a groundbreaking paper by \tbf{Einstein, Podolsky and Rosen (EPR)} \cite{epr}, the so called \tbf{EPR paradox}.

The thought experiment involves a pair of particles prepared in such \tit{entangled state}. Einstein, Podolsky, and Rosen pointed out that, in this state, if the position of the first particle were measured, the result of measuring the position of the second particle \tit{could be predicted}. If instead the momentum of the first particle were measured, then the result of measuring the momentum of the second particle could be predicted. They argued that no action taken on the first particle could instantaneously affect the other, since this would involve information being transmitted faster than light, which is impossible according to the theory of relativity. Einstein famously called this phenomenon \curlyquotes{spooky action at a distance}, and to the best of our knowledge the theory of quantum mechanics says that if we have two engangled states, and measure one of them --- for instance, say that it collapses to $\ket 0$ --- the other state will \tbf{instantaneously} collapse to $\ket 1$ (and viceversa). They are \tit{perfectly anti-correlated}, even if the two states are phisically light-years away from each other.

To finish off this section, we can actually generate entangled states, or \tbf{EPR pairs} for short, through quantum gates as such:

\centeredimage[The quantum circuit for $\ket{\Phi^+}$.]{0.8}{../assets/epr.png}

In particular, we observe that the first Hadamard gate will transform $\ket 0$ to $\dfrac{1}{\sqrt 2}\rbk{\ket 0 + \ket 1}$, and through the CNOT operation we obtain $$\ket{\Phi^+} := \dfrac{1}{\sqrt 2}\rbk{\ket{00} + \ket{11}}$$

\subsection{No-cloning theorem}

An operation that we take for granted in classical computation is the possibility to \tit{copy} the value of a bit: if Alice has two bits $x, y \in \{0, 1\}$, and she wants to copy the value of $x$ into $y$, she can do it without any issues. However, in quantum mechanics this is \tit{not} possible, because it would quite literally violate the laws of physics --- as far as we understand it.

In 1982 \textcite{nocloning} proved the so called \tbf{no-cloning theorem}, which states that it is impossible to create an independent and identical copy of an arbitrary \tit{unknown} quantum state.

\begin{framedthm}{No-cloning theorem}
	There is no quantum transformation that copies an unknown quantum state.
\end{framedthm}

\begin{proof}
	by way of contradiction, suppose that there exists such a transformation CP that is able to copy an unknown quantum state --- and in particular, we observe that such transformation would have to be linear. But clearly, in order to have a copy we need to actually \tit{store} it somewhere, so we can assume that CP has to take two inputs, one being the state that we want to copy and the other one being the state that we want to replace with the copy of the first one. In other words, we are assuming that $$\exists y \forall x \quad \mbox{CP}(x \otimes y) = x \otimes x$$ Now, through some algebraic manipulation we get that
	\begin{equation*}
		\begin{alignedat}{2}
			       & \exists y \forall x \quad \mbox{CP}(x \otimes y) = x \times x                                                  &                                         \\
			\equiv & \exists y \forall x, a \quad \mbox{CP}((x + a) \otimes y) = (x + a) \otimes (x + a)                            &                                         \\
			\equiv & \exists y \forall x, a \quad \mbox{CP}(x \otimes y + a \otimes y) = (x + a) \otimes (x + a)                    & (\mbox{by distributivity of $\otimes$}) \\
			\equiv & \exists y \forall x, a \quad \mbox{CP}(x \otimes y) + \mbox{CP}(a \otimes y) = (x + a) \otimes (x + a)         & (\mbox{by linearity of CP})             \\
			\equiv & \exists y \forall x, a \quad x \otimes x + a \otimes a = x \otimes x + x \otimes a + a \otimes x + a \otimes a & \quad (\mbox{by definition of CP})      \\
			\equiv & \exists y \forall x, a \quad \mathbf 0 = x \otimes a + a \times x
		\end{alignedat}
	\end{equation*}
	which should be true for every $x$ and every $a$, however it does not hold for $x = \ket 0$ and $a = \ket 1$, thus raising a contradiction $\lightning$.
\end{proof}

The no-cloning theorem represents an inherent limitation of quantum computation, and has direct impacts on \tbf{quantum cryptography} and \tbf{quantum error correction}, but must importantly it directly impacts a phenomenon called \tbf{quantum teleportation}

\subsection{Quantum teleportation}

So far we saw that quantum states cannot be cloned, but can we at least \tit{send} them? Suppose that Alice wants to send Bob $\ket \psi$, described by some $\alpha$ and $\beta$. Clearly, the only thing that Bob has to receive are indeed the probability amplitudes of $\ket \psi$, so even if Alice cannot clone her quantum state, nothing prevents her to build a quantum circuit which \tit{destroys} her $\ket \psi$ but does allow Bob to receive $\alpha$ and $\beta$.

The following is the circuit that allows \tbf{quantum teleportation}:

\centeredimage[The Quantum Teleportation circuit.]{0.8}{../assets/telep.png}

There is quite a lot to unpack in this diagram. First, the quantum state that we want to teleport is $q_0$ in this diagram, and it will be teleported in $q_2$ at the end of the quantum computation.

In the first part of the circuit, we see that $q_1$ and $q_2$ are entangled in a Bell state thanks to the Hadamard and the CNOT gates --- as we described in previous sections. In a real-world scenario, we will assume that $q_1$ and $q_2$ are given to Alice and Bob respectively, and quantum mechanics will guarantee that the teleportation will work even our two protagonists are thousands of kilometers away from each other.

After entangling $q_1$ and $q_2$, we have the part of circuit that concerns Alice: in fact, she must apply a CNOT to her entangled qubit $q_1$, controlled by $q_0$, and then apply a Hadamard transformation to $q_0$. At this point, the circuit must apply a measurement to both $q_0$ and $q_1$ --- and in particular, this operation will \tit{destroy} the original state as previously anticipated.

Finally, it's Bob's turn: to obtain the original quantum state of $q_0$, the only thing he needs to do is first apply a CNOT to his entangled qubit $q_2$, controlled by $q_1$'s outcome, followed by an application of a CZ, controlled by $q_0$'s outcome instead --- we observe that this part is indicated in the diagram through the $0 \times 2$ and $0 \times 1$ labels respectively. In fact, in the label $0 \times X$ the number $X$ represents the hexadecimal representation of the binary number obtained by joining the classical bits all together --- for instance, in this circuit we have that 2 represents 10, meaning that only $q_1$ will be checked in the condition, and 1 represents 01, which means that only $q_0$ will be the control bit.

\printbibliography % UNCOMMENT FOR BIBLIOGRAPHY

\end{document}
