\chapter{Quantum Error Correction}

TODO \todo{introduction}

\section{Repetition codes}

\subsection{Three bits bit flip code}

Before discussing error correction in quantum contexts, let's present what how the classical world handles noise in communications. Suppose we have two parties, Alice and Bob, and say that Alice wants to send Bob some bit $b \in \B$. However, the channel they has at their disposal is \tbf{noisy}, meaning that with some probability $p$ the bit she sends will be flipped and Bob will receive the wrong information --- we will assume that each flip is independent of each other. How can Alice raise the odds of Bob getting the bit she originally sent? What she needs is some type of \tit{redundancy}, and the most straightforward and way to achieve it is clearly \tbf{repetition}.

Therefore, suppose Alice now sends 2 bits to Bob instead of one, such that both bits are equal to the original $b$ she intended to sent $$b = b_0 = b_1$$ Her idea is to make Bob able to recover the original $b$ by looking at both $b_0$ and $b_1$. However, there is an issue with this idea: since both $b_0$ and $b_1$ could flip during the transmission, its easy to see that if $b_0 \neq b_1$ Bob has no way to determine what $b$ was. This suggests that what Alice needs to provide is \tit{more} information!

Suppose that Alice now sends $b_0$, $b_1$ and $b_2$ such that $$b = b_0 = b_1 = b_2$$ and for now, let's assume that $b_0$ flipped during the transmission. Then, Bob will see that $$b_0 \neq b_1 = b_2$$ which ultimately helps him determine that the value Alice wanted to send is contained in the bits $b_1$ and $b_2$, and $b_0$ flipped because of the noise. For a more practical example, if Alice wants to send 0 to Bob she transmits 000 through the noisy medium, but whenever Bob receive 100 he will infer that what Alice actually sent was 000, therefore the bit he was meant to receive was 0.

This idea is called \tit{majority voting}, as Bob decides how to recover the bit by looking at the value of the bits that appears more often, however its easy too see a very big flaw of this approach: with 2 or more bit flips the majority voting fails! If Bob receives 110, by majority he will infer that we was meant to receive 1 from Alice, however he cannot be sure that what really happened is that both $b_0$ and $b_1$ flipped through the transmission and what Alice originally sent was 0. In general, we have that
\begin{equation*}
	\begin{split}
		\Pr[\mbox{recovering the wrong bit}] & = \Pr[\mbox{at least 2 two bits flipped}]                 \\
		                                     & = \Pr[\mbox{2 bits flipped}] + \Pr[\mbox{3 bits flipped}] \\
		                                     & = 3p^2(1 - p) + p^3                                       \\
		                                     & = 3p^2 - 3p^3 + p^3                                       \\
		                                     & = 3p^2 - 2p^3
	\end{split}
\end{equation*}
This means that as long as $$3p^2 - 2p^3 < p \iff p < \dfrac{1}{2}$$ this error correction code improves reliability. The codes of these type are called \tbf{repetition codes}, as they rely on repeating the same information multiple times for increase the probability of transmitting the correct information.

\subsection{Three qubits bit flip code}

Can we replicate the same idea in a quantum setting? More specifically, suppose that Alice wants to send a qubit $$\ket \psi = \alpha \ket 0 + \beta \ket 1$$ to Bob through a quantum channel, however said channel is noisy and might introduce errors with probability $p$ at each transmission they perform. Because of the peculiarities of the quantum worlds, we know there are some important differences between classical and quantum information that require new ideas in order to apply the same redundancy technique presented:

\begin{itemize}
	\item first and foremost, the \nameref{nct} forbids the cloning of a quantum state multiple times, so it is not as straightforward as in the classical context to produce the needed redundancy
	\item in the quantum context values are \tbf{continuous}, and errors are continuous as well, meaning that determining which error occurred would appear to require infinite precision --- more details about this will be discussed later
	\item in classical error correction Bob can just check the values of the received bits and that's it, however upon receiving qubits Bob cannot simply \tbf{measure} them to \curlyquotes{look at their value}, otherwise he would destroy all the information making the recovery impossible
\end{itemize}

Fortunately, we can circumvent all of these problems with some clever ideas. First, consider the following quantum circuit:

\begin{figure}[H]
	\[
		\Qcircuit @C=2.5em @R=2.5em {
		& \lstick{\ket \psi}    & \ctrl{1}  & \ctrl{2} & \qw \\
		& \lstick{\ket 0}       & \targ  & \qw & \qw      \\
		& \lstick{\ket 0}       & \qw    & \targ   & \qw \\
		}
	\]
	% \caption{The circuit.}
\end{figure}

Let's analyze what this circuit does:

\begin{equation*}
	\begin{split}
		                                    & \ket \psi \otimes \ket 0 \otimes \ket 0                                   \\
		=                                   & (\alpha \ket 0 + \beta \ket 1) \otimes \ket 0 \otimes \ket 0              \\
		=                                   & (\alpha \ket {00} + \beta \ket {10}) \otimes \ket 0                       \\
		\xrightarrow{\mbox{CNOT}(q_0, q_1)} & \mbox{CNOT}(\alpha \ket {00} + \beta \ket {10}) \otimes \ket 0            \\
		=                                   & (\alpha \mbox{CNOT} \ket{00} + \beta \mbox{CNOT}\ket{10} ) \otimes \ket 0 \\
		=                                   & (\alpha \ket {00} + \beta \ket{11}) \otimes \ket 0                        \\
		\xrightarrow{\mbox{CNOT}(q_0, q_2)} & \alpha \ket{000} + \beta \ket{111}                                        \\
	\end{split}
\end{equation*}

This is exactly what we needed: we started with a state $\ket \psi = \alpha \ket 0 + \beta \ket 1$ and we ended up with $$\ket{\hat \psi} = \alpha \ket{000} + \beta \ket{111}$$ which yields the redundancy we need in order to utilize the repetition strategy.

Now, suppose that Alice sends each of the three qubits through the noisy quantum channel, and each qubit will experience the effect of the noise, independently, with probability $p$. But what is this effect in practice? So far, we did not mention the word \tit{flip}, because we actually need to define what a \tit{flip} even is in this context. Well, if a \curlyquotes{classical bit flip} is an application of a NOT operator on some bit $b_i$, it makes sense to define a \curlyquotes{quantum bit flip} as the application of the $X$ operator of some $q_i$ sent, analogously.

However, this immediately shows that there is a \tbf{continuous spectrum} of possible errors that can occur to the qubits --- namely every possible linear transformation --- and apart from the $X$ gate itself none of them have a classical analogue! For now, let's just focus on the $X$ operator, and suppose that \tit{at most one} bit flip occurred on the qubits Alice sent to Bob. How can Bob recover the original message? Consider the following table:

\begin{center}
	\begin{tabular}{l|l}
		\hline
		Projector                                         & Error occured      \\
		\hline\hline
		$P_0 = \ket{000} \bra{000} + \ket{111} \bra{111}$ & No error occurred  \\
		\hline
		$P_1 = \ket{100} \bra{000} + \ket{011} \bra{011}$ & First bit flipped  \\
		\hline
		$P_2 = \ket{010} \bra{010} + \ket{101} \bra{101}$ & Second bit flipped \\
		\hline
		$P_3 = \ket{001} \bra{001} + \ket{110} \bra{110}$ & Third bit flipped  \\
		\hline
	\end{tabular}
\end{center}

This table contains 4 projectors that Bob can apply to discover which qubit, if any, flipped during the transmission. We underline that Bob \tit{must} use these projectors in order to understand which bit flip happend, because he cannot measure what he received. For instance, say that the first bit flipped during the transmission, i.e. Bob receives $$\ket{\hat \psi} = \alpha \ket{100} + \beta \ket{011}$$ Then, when he applies $P_1$ to $\ket{\hat \psi}$ he discovers that
\begin{equation*}
	\begin{split}
		\braket{\hat \psi|P_1 \hat \psi} & = \braket{\hat \psi|(\ket{100} \bra{000} + \ket{011} \bra{011})(\alpha \ket{000} + \beta \ket{111})} \\
		                                 & = \braket{ \hat \psi| \alpha \ket{100} + \beta \ket{011}}                                            \\
		                                 & = \braket{\hat \psi | \hat \psi}                                                                     \\
		                                 & = 1                                                                                                  \\
	\end{split}
\end{equation*}
This means that Bob is sure that the second bit flipped, hence the original message can be recovered flawlessly by flipping the second qubit received. Again, this error correction procedure works perfectly, provided that bit flips occur on at most one qubit per message, so reliability still requires that $p < 1/2$.

TODO \todo{add slide 14 and 15}

\subsection{Three qubits phase flip code}

As previously mentioned, the case of the $X$ gate is \curlyquotes{easy} to solve, in the sense that it requires no significant innovation w.r.t. any classical context. However, what if instead of performing an application of the $X$ operator with probability $p$, our noisy channel applies the $Z$ transformation instead? When Alice sends her qubit $\ket \psi = \alpha \ket 0 + \beta \ket 1$ it is transformed with probability $p$ into $$Z \ket \psi = \alpha \ket 0 - \beta \ket 1$$ As previously mentioned, this scenario has no classical analogue, but it is still easy to handle. In fact, we already know a key fact: the $Z$ operator acts like a standard bit flip in the $Z$ basis, i.e. $$Z \ket +  = \ket - \quad \quad Z \ket - = \ket +$$ This suggests that we can still employ the same redundancy strategy of the previous section, provided that we perform a change of basis. Luckily, we already know a matrix that performs the change from the X to the Z bases, as discussed in \cref{measurements}, namely the Hadamard operator! Therefore, all Alice has to do is send the following:

\begin{figure}[H]
	\[
		\Qcircuit @C=2.5em @R=2.5em {
		& \lstick{\ket \psi}    & \ctrl{1}  & \ctrl{2} & \gate{H} & \qw \\
		& \lstick{\ket 0}       & \targ  & \qw & \gate{H} & \qw      \\
		& \lstick{\ket 0}       & \qw    & \targ   & \gate{H} & \qw \\
		}
	\]
	% \caption{The circuit.}
\end{figure}

meaning that at the end of the circuit we will get exactly:
\begin{equation*}
	\begin{split}
		                                           & \ket \psi \otimes \ket 0 \otimes \ket 0                        \\
		\xrightarrow{\ldots}                       & \ldots                                                         \\
		=                                          & \alpha \ket{000} + \beta \ket{111}                             \\
		\xrightarrow{H^{\otimes 3}(q_0, q_1, q_2)} & H^{\otimes 3}(\alpha \ket{000} + \beta \ket{111})              \\
		=                                          & \alpha H^{\otimes 3} \ket{000} + \beta H^{\otimes 3} \ket{111} \\
		=                                          & \alpha \ket{+++} + \beta \ket{---}                             \\
	\end{split}
\end{equation*}

Then, Bob can discover if a qubit phase flip occured through the following table:
\begin{center}
	\begin{tabular}{l|l}
		\hline
		Projector                                         & Error occured        \\
		\hline\hline
		$P_0 = \ket{+++} \bra{+++} + \ket{---} \bra{---}$ & No error occurred    \\
		\hline
		$P_1 = \ket{-++} \bra{-++} + \ket{+--} \bra{+--}$ & First phase flipped  \\
		\hline
		$P_2 = \ket{+-+} \bra{+-+} + \ket{-+-} \bra{-+-}$ & Second phase flipped \\
		\hline
		$P_3 = \ket{++-} \bra{++-} + \ket{--+} \bra{--+}$ & Third phase flipped  \\
		\hline
	\end{tabular}
\end{center}

Once Bob learns which qubit phase flipped (if any) he can apply a $Z$ operator to the corresponding qubit. We say that the channel that applies the $X$ matrix and the one that applies the $Z$ martix are \tbf{unitarily equivalent}, since there is a unitary operator --- the Hadamard gate, in this case --- such that the action of one channel is the same as the other, provided that the first channel is preceded by $U$ and followed by $U^\dag$ in every operation performed --- we will leave the proof of this fact as an exercise.

TODO \todo{i have no idea what slide 19 is saying}

\subsection{The Shor code}

The last quantum repetition code we will present is called \tbf{Shor code}, after its inventor, and it is a simple code that protecs againts the effects of at most one \tit{arbitrary Pauli error} on any qubit. Not surprisingly, the code is a combination of the three qubit bit and phase flip codes we saw earlier. In particular, we observe that in the bit flip code the quantum circuit acted on $\ket 0$ and $\ket 1$ as follows: $$\ket 0 \xrightarrow{\mbox{bit flip code}} \ket{000}$$ $$\ket 1 \xrightarrow{\mbox{bit flip code}} \ket{111}$$ Similarily, the circuit for the phase flip acted as follows: $$\ket 0 \xrightarrow{\mbox{phase flip code}} \ket{+++}$$ $$\ket 1 \xrightarrow{\mbox{phase flip code}} \ket{---}$$ Then, the Shor code applies the following transformation: $$\ket 0 \xrightarrow{\mbox{phase flip code}} \ket{+++} \xrightarrow{\mbox{bit flip code}} \dfrac{1}{\sqrt 8}(\ket{000} + \ket{111})^{\otimes 3}$$ $$\ket 1 \xrightarrow{\mbox{phase flip code}} \ket{---} \xrightarrow{\mbox{bit flip code}} \dfrac{1}{\sqrt 8}(\ket{000} - \ket{111})^{\otimes 3}$$ Indeed, this code is able to detect any Pauli error on any qubit, meaning that it can detect if either

\begin{itemize}
	\item a bit flip
	\item a phase flip
	\item both a bit and a phase flip
\end{itemize}

occurred on at most one transmitted qubit --- and it also works by switching the order of the concatenated codes. This is because

\begin{itemize}
	\item bit flips correspond to $\sigma_x$
	\item phase flip correspond to $\sigma_z$
	\item $\sigma_y = i \sigma_x \sigma_z$, so we can correct $Y$ transformations as well
\end{itemize}

Therefore, we just need to apply the procedures for detecting bit and phase flips one after the other in order to retrieve the original message.

We note that the fact that the Shor code actually enables the correction of combined bit and phase flip errors on a single qubit suggests that we could use the Shor code for more complicated type of errors. However, we might expect some additional work to be done in order to be protected against \tbf{arbitrary errors}, however quite suprisingly we can actually prove that this code detects any possible error with \tit{no additional work required}! At the beginning of our discussion we said that there is a \tit{continuum} of errors that may occur on a single qubit, which may seem to imply that we need much more sophisticated quantum error correction procedures, however such continuum can actually be handled by correcting only a \tit{discrete} subset of it. All the other possible errors are corrected automatically. The discretization of the errors is central to why quantum error-correction works, and should be regarded in contrast to classical error-correction for analog systems, where no such discretization of errors is possible.

\begin{framedthm}{}
	Any quantum error-correcting code that corrects at most $k$ Pauli errors on at most $k$ qubits will also correct an arbitrary quantum operation on thos qubits.
\end{framedthm}

\begin{proof}[Idea of the proof.]
	TODO \todo{pag 434 of the book}
\end{proof}

% What about generic unitary transformations that


